#!/usr/bin/env python
# coding: utf-8

# # 학습 목표
# - 파이썬 자료형을 구분할 수 있습니다.
# - 데이터를 보고 파이썬의 자료형을 알맞게 추측할 수 있습니다.
# - 자료형의 참과 거짓을 판별할 수 있습니다.

# # 학습 목표
# - 파이썬 자료형을 구분할 수 있습니다.
# - 데이터를 보고 파이썬의 자료형을 알맞게 추측할 수 있습니다.
# - 자료형의 참과 거짓을 판별할 수 있습니다.

# # 학습 목표
# - 파이썬 자료형을 구분할 수 있습니다.
# - 데이터를 보고 파이썬의 자료형을 알맞게 추측할 수 있습니다.
# - 자료형의 참과 거짓을 판별할 수 있습니다.

# In[ ]:





# # 파이썬이란?
# 
# 파이썬(python)이란, 프로그래밍 언어 중 하나입니다. 컴퓨터는 프로그램에 기록된 명령을 순서대로 꺼내 실행한다. 이러한 프로그램을 만드를 것이 프로그래밍 언어이다. 파이썬 하나만 잘 배워도 웹 개발, 앱 개발, 데이터분석, 인공지능, 업무 자동화 등 정말 다양한 분야에서 활용할 수 있다.

# # 식별자
# ## 예약어(키워드)
# ### 자주 쓰이는 예약어
# 
# ![image.png](attachment:image.png)

# ## 스네이크와 캐멀
# 
# 식별자는 공백을 사용할 수 없기 때문에 식별자의 의미 파악이 어려울 때가 많다. 
# 
# ![image.png](attachment:image.png)
# 
# 위 식별자들이 의미를 이해할 수도 있지만, 공백이 없어서 재빠르게 이해하기 힘들다. 그래서 개발자들은 뱀과 낙타 모양 방법을 사용해 식별자를 쉽게 이해할 수 있도록 했다. 
#   
#   
#   
# 식별자의 모양으로 해당 식별자를 빠르고 쉽게 이해하기 위해 쓰임.
# - 스네이크 케이스 : 단어 사이에 언더 바(_)기호를 쓰는 방법
# - 캐멀 케이스 : 단어들의 첫 글자를 대문자로 쓰는 방법
# 
# ex)
# 스네이크 케이스 : we_love_AIFFEL  
# 캐멀 케이스 : WeLoveAiffel
# 
# 스네이크 케이스 - 뒤에 괄호가 없다 : **변수**
#                 - 뒤에 괄호가 있다 : **함수**  
# 캐멀 케이스 : **클래스**

# # 주석과 출력
# ## 주석
# 주석(comment)은 프로그램 진행에 전혀 영향을 주지 않는 코드로 프로그램을 설명하기 위해 사용.  
# - #기호  
# - 주석 단축키 : 'ctrl + /
# 
# ## 출력
# - print()함수
# ![image.png](attachment:image.png)

# In[1]:


# 하나만 출력하기
print(123)

# 여러 개 출력하기 
print('안녕', 111, '123')


# In[2]:


# 비어있는 print() # ()안에 아무것도 입력하지 않으면 줄바꿈
print()


# In[3]:


# 알아두면 유용할거임
print('-'*25)
print()
print()
print('-'*25)


# # 숫자형 (int, float)
# - **정수형(int)**
# : 정수를 뜻하는 자료형
# - **실수형(float)**
# : 소수점이 포함된 숫자 자료형  
#   
# 자료형을 알아볼 때 쓰는 함수 type()으로 자료형의 타입을 알 수 있다. 

# In[4]:


type(10)


# In[6]:


type(-5.0)


# ## 숫자형 연산(산술 연산자)
# 

# In[1]:


# 정수 + 정수
1 + 2

# 실수 - 실수
1.0 - 2.0

# 정수 * 실수
1 * 2.0


# - 특별한 연산자  
# 
# ![image.png](attachment:image.png)

# ## 복합 대입 연산자
# **연산과 할당을 합쳐 놓은 것**이며, 간결한 식을 위해서 사용함.  
# 
# ![image.png](attachment:image.png)

# In[21]:


# 원래 대입식
a = 7
a = a + 1
print(a)

# 복합 대입 연산자(덧셈)
a = 7
a += 1
print(a)


# In[22]:


# 원래 대입식
b = 5
b = b * 2
print(b)

# Q. 복합 대입 연산자 (곱셈)
b = 5
b *= 2
print(b)


# # 문자형(str)  
# 
# 따옴표에 둘려싸여 있음. (string)  
# 
# ### 문자열을 만드는 4가지 방법
# 1. 큰 따옴표(")로 둘러싸기
# 2. 작은 따옴표(')로 둘러싸기
# 3. 큰 따옴표 연속 3개(""")로 둘러싸기
# 4. 작은 따옴표 연속 3개(''')로 둘러싸기

# In[23]:


# 큰 따옴표
"AIFFEL", type("AIFFEL")

# 작은 따옴표
'환영합니다!', type('환영합니다!')

# 큰 따옴표 연속 3개
"""끝까지 열심히""", type("""끝까지 열심히"""
                    
# 작은 따옴표 연속 3개
'''파이썬 공부해요!''', type('''파이썬 공부해요!''')


# In[24]:


# 문자열이 여러 줄인 경우(큰 따옴표 연속 3개)
python = """파이썬이 
이렇게
재밌다니!"""

print(python)


# ### 이스케이프 코드(Escape Sequence)
# 
# ![image.png](attachment:image.png)

# In[25]:


tabline = 'hello\npython'
print(tabline)


# In[26]:


hwang = '밤하늘의 별을 따서 너에게 줄개\n너는 내가 사랑하니까 더 소중하니까\n오직 너 아니면 안 된다고 외치고 싶어'
print(hwang)


# 이스케이프 코드에서 행 계속 문자(또는 행 연속 문자) \는 문자열 정의뿐만 아니라 코드에도 사용할 수 있다.  
# 코드가 너무 길어진다 싶으면 가독성을 위해서 행 끝에 \를 두고 식을 계속 쓰면 됨.

# In[27]:


num =\
13*1 +\
13*2 +\
13*3 +\
13*4

print(num)


# ### len()
# 
# 문자열의 길이는 len()함수로 구함.
# 

# In[28]:


python = """파이썬이 
이렇게
재밌다니!"""

len(python)


# len()은 따옴표 안에 있는 문자를 세서 길이를 리턴합니다. 위의 코드에서는 느낌표(!)와 개행되는 부분까지 센 결과가 나왔습니다.

# In[29]:


tabline = 'hello\tpython'
len(tabline)


# 이스케이프 코드를 포함하여 길이를 리턴함.
# 

# ### 문자열 인덱싱(Indexing)  
# 
# 인덱싱(indexing)은 무엇인가를 가리킨다는 의미. [ ]대괄호 안에 인덱스를 넣어서 표현할 수 있다.  
# 
# - 제일 앞 문자의 인덱스는 1이 아니고 0부터 시작함.  
# - 추가로 0과 -0은 똑같기 때문에 a[0]과 a[-0]은 동일한 값이다.  
# - 공백을 포함한 문자열에서는 공백도 인덱싱 가능.
# 
# ![image.png](attachment:image.png)

# In[30]:


a = 'python'
a[2]


# In[31]:


b = 'hello aiffel'
b[4], b[5], b[6]


# ### 문자열 슬라이싱(Slicing)
# 
# 슬라이싱(slicing)은 무엇인가를 자른다는 의미.  
# 
# 괄호 안에 숫자를 넣는 점이 인덱싱과 비슷하지만, 콜론 앞뒤에 숫자를 넣어 [:]로 표현하며 문자열의 일부를 가져올 수 있다.  
# 주의할 점, 뒤에 들어가는 숫자 N은 해당 인덱스에서 +1을 해줘야한다는 것.(인덱스는 0부터 시작하기 때문)  
# 
# 예를들어, slicing = 'hello aiffel'이라는 변수에서 'hello'를 추출하고 싶다면 ->
# 'o'의 인덱스는 4이기 때문에 slicing[5]를 해야함.  
# 
# ![image.png](attachment:image.png)

# In[32]:


slicing = 'hello aiffel'  
# 출력값:  'hello aiffel' 
print('전체 출력', slicing[:])
# 출력값: 'hello'
print('처음부터 5번째까지 출력 :', slicing[:5])  
# 출력값: 'aiffel'
print('6번째부터 마지막까지 출력 :', slicing[6:]) 
# 출력값:  'ai'
print('6번째부터 8번째까지 출력 :', slicing[6:8])


# 12345'에서 '135'만 추출하려면?   
# 위에서 배운 슬라이싱에 콜론:하나만 더 추가하면 됩니다. [::] 이런 모양입니다.  [::2]라면, 처음부터 끝까지 인덱스 2 간격으로 출력이 됩니다. 비슷한 원리로 [n:N:m]을 사용하면 n부터 N까지 m 간격으로 출력합니다. 아래 예시를 통해 이해해봅시다.

# In[33]:


num = '123456789'
 
print(num[::]) #전체 출력
print(num[::2]) #전체를 2 간격으로 출력
print(num[1:8:2]) # 인덱스 1번부터 7번까지 2 간격으로 출력


# In[34]:


# 어떤 결과가 나올지 예상한 뒤 코드 실행 버튼을 눌러주세요.
num[-8:-1:3]


# ---
# # 리스트(list)
# 
# 리스트의 자료형은 대괄호 [ ] 안에서 요소를 콤마 , 로 써주면 됨.
# 
# ![image.png](attachment:image.png)

# In[35]:


# 리스트 안에는 어떠한 자료형도 포함시킬 수 있습니다. 
a = [0, 1, 2, 3]  # 숫자형
b = ['AIFFEL', '화이팅'] # 문자형
c = [1, 2, 'AIFFEL', '화이팅'] # 숫자형, 문자형
d = [1, 2, ['AIFFEL', '화이팅']] # 숫자형, 리스트

d


# In[36]:


# 비어 있는 리스트로 생성할 수 있습니다.
e = []
e


# In[37]:


# list() 함수를 사용해서 빈 리스트를 만들 수 있습니다.
f = list()
f


# ## 리스트 인덱싱 & 슬라이싱
# 

# In[38]:


# 문자열과 동일하게 인덱싱할 수 있습니다.

# 음수 인덱싱: 뒤에서부터 인덱싱합니다.
a = [1, 2, 3, 4, 5]
a[-1]


# In[39]:


# 리스트 안의 element인 리스트도 인덱싱할 수 있습니다.
a = [1, 2, ['AIFFEL', '화이팅'], 3, 4]
a[2]


# In[40]:


# 'AIFFEL'만 인덱싱할 수 있습니다.
a = [1, 2, ['AIFFEL', '화이팅'], 3, 4]
a[2][0]


# ## 리스트 연산하기

# In[42]:


# 리스트 사이의 더하기(+) 연산자는 리스트를 합칩니다.
list1 = [1, 2, 3]
list2 = ['a', 'b', 'c']
list1 + list2


# In[43]:


# 리스트 사이의 곱셈(*) 연산자는 리스트를 반복합니다.
list2 * 2


# In[44]:


len(list2)


# In[45]:


list2 = ['a', 'b', 'c']
del list2[1]
list2


# # 튜플(tuple)
# 
# 튜플 자료형은 소괄호( ) 안에 요소를 콤마 , 로 구분해 줌.
# 
# ![image.png](attachment:image.png)
# 
# 소괄호를 () 를 생략해도 됨.
# 
# ![image-2.png](attachment:image-2.png)

# * 튜플에서 가장 중요한 것은 편집할 수 없다, 즉 변경할 수 없다.  
# 인덱싱과 슬라이싱은 해당 튜플을 변경하는 것이 아니기 때문에 가능하지만, 요소를 추가 또는 삭제하는 것은 불가능 함.
# 

# In[46]:


#인덱싱: 튜플에서 가능
tu1 = 1, 2, 3, 4, 5
tu1[0]


# In[47]:


# 요소 삭제 : 튜플에서는 불가능
tu1 = (1, 3, 5)
del tu1[1]


# # 집합(set)
# 집합은 중괄호 { } 안에 값을 넣고 콤마 , 로 구분해 줌. 
# 
# ![image.png](attachment:image.png)

# In[48]:


# 중괄호{} 안에 값을 넣고 콤마(,)로 구분합니다.
# 중복은 허락되지 않습니다.
asia = {'korea', 'china', 'japan', 'korea'}
asia


# In[49]:


# set()에 문자열을 넣어봅시다. 어떤 결과가 나올까요?
a = set('hello')
a


# ## 집합 연산  
# 
# ![image.png](attachment:image.png)

# In[50]:


a = {2, 4, 6, 8, 10, 12} 
b = {3, 6, 9, 12, 15}

# 합집합 기호 
a | b

# 합집합 함수
a.union(b)


# In[51]:


# 교집합 기호
a & b

# 교집합 함수
a.intersection(b)


# In[52]:


# 차집합 기호
a - b

# 차집합 함수
a.difference(b)


# In[54]:


# 배타적 차집합 기호
a ^ b

# 배타적 차집합 함수
a.symmetric_difference(b)


# # 딕셔너리(dictionary)  
# 
# 딕셔너리는 **키(key)와 값(Value)의 쌍**을 저장하는 대용량의 자료구조  
# 딕셔너리 자료형은 중괄호 { } 안에 key:Value 형대를 넣고 콤마 , 로 구분해 줌.
# 
# ![image.png](attachment:image.png)

# In[1]:


# 중괄호{} 안에 Key:Value 형태를 넣고 콤마(,)로 구분합니다.  
# 순서가 달라져도 동일한 딕셔너리입니다.
dic1 = {'apple':'사과', 'orange':'오렌지', 'melon':'멜론', 'num':8}
dic2 = {'orange':'오렌지', 'apple':'사과', 'melon':'멜론', 'num':8}
dic1 == dic2


# In[3]:


# 키(Key)는 중복되면 안되고, 값(Value)은 중복되어도 상관없습니다.
# 중복되는 키(apple)가 있을 때는 어떻게 될까요? 
dic = {'apple':'사과', 'orange':'오렌지', 'melon':'멜론',\
       'num':8, 'apple':'꿀사과', 'num_2':8}
dic
dic['apple']


# # 불(bool)
# 
# 
